#!python
# vim: syntax=python tabstop=4 expandtab
# coding: utf-8

sample="S1_R"

rule all:
  input:
    sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map.fltr.clip" + ".bam"

rule picard_FastqToSam:
#TODO: add -Xmx4f memory to java
#TODO: add jar excution to picard
    input:
        fq1=sample + "_1." + "fastq.gz",
        fq2=sample + "_2." + "fastq.gz",
    output:
        sample + ".unalg" + ".bam"
    params:
        sample = sample
    shell:
        """
picard FastqToSam \
--O={output} \
F1={input.fq1} \
F2={input.fq2} \
SM={params.sample} \
LB=Library1 \
PU=Unit1
PL=illumina
        """
rule fgbio_ExtractUmisFromBam:
    input:
        sample + ".unalg" + ".bam"
    output:
        sample + ".unalg.umi" +  ".bam"
    shell:
        """
fgbio ExtractUmisFromBam \
--input={input} \
--output={output} \
--read-structure=3M2S146T 3M2S146T \
--molecular-barcode-tags=ZA ZB \
--single-tag=RX
        """

rule picard_MarkIlluminaAdapters:
    input:
        sample + ".unalg.umi" + ".bam"
    output:
        bam = sample + ".unalg.umi.mrkadp" + ".bam",
        txt = sample + ".unalg.umi.mrkadp" + ".txt"
    shell:
        """
picard MarkIlluminaAdapters \
I={input} \
O={output.bam} \
M={output.txt}
        """

rule picard_SamToFastq:
    input:
        sample + ".unalg.umi.mrkadp" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp" + ".fastq"
    shell:
        """
picard SamToFastq {input} {output}
        """

rule bwa_mem_umi_mrkadp:
    input:
        sample + ".unalg.umi.mrkadp" + ".fastq"
    output:
        sample + ".unalg.umi.mrkadp.bwa" + ".bam"
    shell:
        """
bwa mem {input} {output}
        """
rule picard_MergeBamAlignment_mrkadp:
    input:
        sample + ".unalg.umi.mrkadp.bwa" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map" + ".bam"
    shell:
        """
picard MergeBamAlignment {input} {output}
        """

rule fgbio_GroupReadsByUmi:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi" + ".bam"
    shell:
        """
fgbio GroupReadsByUmi {input} {output}
        """
rule fgbio_CallDuplexConsensusReads:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg" + ".bam"
    shell:
        """
fgbio CallDuplexConsensusReads {input} {output}
        """
rule picard_SamToFastq_cnsalg:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg" + ".fastq"
    shell:
        """
picard SamToFastq {input} {output}
        """

rule bwa_mem_umi_cnsalg:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg" + ".fastq"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa" + ".bam"
    shell:
        """
bwa mem {input} {output}
        """

rule picard_MergeBamAlignment_cnsalg:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map" + ".bam"
    shell:
        """
picard MergeBamAlignment {input} {output}
        """

rule fgbio_FilterConsensusReads:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map.fltr" + ".bam"
    shell:
        """
fgbio FilterConsensusReads {input} {output}
        """

rule fgio_ClipBam:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map.fltr" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.cnsunalg.bwa.map.fltr.clip" + ".bam"
    shell:
        """
fgbio ClipBam {input} {output}
        """

rule fgbio_CollectDuplexSeqMetrics:
    input:
        sample + ".unalg.umi.mrkadp.bwa.map.umi" + ".bam"
    output:
        sample + ".unalg.umi.mrkadp.bwa.map.umi.metrics"
    shell:
        """
fgbio CollectDuplexSeqMetrics {input} {output}
        """
