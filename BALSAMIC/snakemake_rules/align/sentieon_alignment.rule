# vim: syntax=python tabstop=4 expandtab
# coding: utf-8

from pathlib import Path
from BALSAMIC.utils.rule import get_threads


# Following rule will take input fastq files, align them using bwa mem, and convert the output to sam format
rule sentieon_align_sort:
    input:
        ref = config["reference"]["reference_genome"],
        read1 = Path(fastq_dir, "{sample}_1.fp.fastq.gz").as_posix(),
        read2 = Path(fastq_dir, "{sample}_2.fp.fastq.gz").as_posix(),
        refidx = expand(config["reference"]["reference_genome"] + ".{prefix}", prefix=["amb","ann","bwt","pac","sa"])
    output:
        bamout = Path(bam_dir, "{sample}.bam").as_posix()
    params:
        tmpdir = tmp_dir,
        header = "'@RG\\tID:" +  "{sample}" + "\\tSM:" + "{sample}" + "\\tPL:ILLUMINAi'",
        sentieon_exec = config["SENTIEON_EXEC"],
        sentieon_lic = config["SENTIEON_LICENSE"],
    threads: get_threads(cluster_config, 'sentieon_align_sort')
    log:
        Path(bam_dir, "{sample}.bam.log").as_posix()
    benchmark:
        Path(benchmark_dir, "sentieon_align_sort_{sample}.align_sort.tsv").as_posix()
    shell:
        """
rand_str=$(openssl rand -hex 5);
tmpdir={params.tmpdir}/${{rand_str}};
mkdir -p ${{tmpdir}};
export TMPDIR=${{tmpdir}};
export SENTIEON_TMPDIR=${{tmpdir}};
export SENTIEON_LICENSE={params.sentieon_lic};

{params.sentieon_exec} bwa mem -M \
-R {params.header} \
-t {threads} \
-K 50000000 \
{input.ref} {input.read1} {input.read2} \
| {params.sentieon_exec} util sort -o {output.bamout} -t {threads} --block_size 3G --sam2bam -i -
        """


rule sentieon_dedup:
    input:
        bam = Path(bam_dir, "{sample}.bam").as_posix(),
    output:
        bam = Path(bam_dir, "{sample}.dedup.bam").as_posix(),
        score = Path(bam_dir, "{sample}.dedup.score").as_posix(),
        metrics = Path(bam_dir, "{sample}.dedup.metrics").as_posix()
    params:
        tmpdir = tmp_dir,
        housekeeper_id = {"id": "{sample}", "tags": "scout"},
        sentieon_exec = config["SENTIEON_EXEC"],
        sentieon_lic = config["SENTIEON_LICENSE"],
    threads: get_threads(cluster_config, 'sentieon_dedup')
    log:
        Path(bam_dir, "{sample}.dedup.bam.log").as_posix()
    benchmark:
        Path(benchmark_dir, "sentieon_dedup_{sample}.dedup.tsv").as_posix()
    shell:
        """
rand_str=$(openssl rand -hex 5);
tmpdir={params.tmpdir}/${{rand_str}};
mkdir -p ${{tmpdir}};
export TMPDIR=${{tmpdir}};
export SENTIEON_TMPDIR=${{tmpdir}};
export SENTIEON_LICENSE={params.sentieon_lic};

{params.sentieon_exec} driver -t {threads} -i {input.bam} --algo LocusCollector --fun score_info {output.score};

{params.sentieon_exec} driver -t {threads} -i {input.bam} --algo Dedup --rmdup --score_info {output.score} --metrics {output.metrics} {output.bam};
        """


rule sentieon_realign:
    input:
        ref = config["reference"]["reference_genome"],
        mills = config["reference"]["mills_1kg"],
        indel_1kg = config["reference"]["1kg_known_indel"],
        bam = Path(bam_dir, "{sample}.dedup.bam").as_posix()
    output:
        bam = Path(bam_dir, "{sample}.dedup.realign.bam").as_posix(),
    params:
        tmpdir = tmp_dir,
        sentieon_exec = config["SENTIEON_EXEC"],
        sentieon_lic = config["SENTIEON_LICENSE"],
    threads: get_threads(cluster_config, 'sentieon_realign')
    log:
        Path(bam_dir, "{sample}.dedup.realign.bam.log").as_posix()
    benchmark:
        Path(benchmark_dir, "sentieon_realign_{sample}.dedup_realign.tsv").as_posix()
    shell:
        """
rand_str=$(openssl rand -hex 5);
tmpdir={params.tmpdir}/${{rand_str}};
mkdir -p ${{tmpdir}};
export TMPDIR=${{tmpdir}};
export SENTIEON_TMPDIR=${{tmpdir}};
export SENTIEON_LICENSE={params.sentieon_lic};

{params.sentieon_exec} driver -r {input.ref} -t {threads} -i {input.bam} --algo Realigner -k {input.mills} -k {input.indel_1kg} {output} 
        """


rule sentieon_base_calibration:
    input:
        ref = config["reference"]["reference_genome"],
        mills = config["reference"]["mills_1kg"],
        indel_1kg = config["reference"]["1kg_known_indel"],
        dbsnp = config["reference"]["dbsnp"],
        bam = Path(bam_dir, "{sample}.dedup.realign.bam").as_posix()
    output:
        recal_data_table = Path(bam_dir, "{sample}.dedup.realign.recal_data.table").as_posix(),
        qual_recal = Path(bam_dir, "{sample}.dedup.realign.recal.csv").as_posix(),
        qual_recal_plot = Path(bam_dir, "{sample}.dedup.realign.recal.pdf").as_posix(),
    params:
        tmpdir = tmp_dir,
        sentieon_exec = config["SENTIEON_EXEC"],
        sentieon_lic = config["SENTIEON_LICENSE"],
    threads: get_threads(cluster_config, 'sentieon_base_calibration')
    log:
        Path(bam_dir, "{sample}.dedup.realign.recal.log").as_posix()
    benchmark:
        Path(benchmark_dir, "sentieon_base_calibration_{sample}.base_recal.tsv").as_posix()
    shell:
        """
rand_str=$(openssl rand -hex 5);
tmpdir={params.tmpdir}/${{rand_str}};
mkdir -p ${{tmpdir}};
export TMPDIR=${{tmpdir}};
export SENTIEON_TMPDIR=${{tmpdir}};
export SENTIEON_LICENSE={params.sentieon_lic};

{params.sentieon_exec} driver -r {input.ref} -t {threads} -i {input.bam} --algo QualCal -k {input.dbsnp} -k {input.mills} -k {input.indel_1kg} {output.recal_data_table};

{params.sentieon_exec} driver -r {input.ref} -t {threads} -i {input.bam} -q {output.recal_data_table} --algo QualCal -k {input.dbsnp} -k {input.mills} -k {input.indel_1kg} {output.recal_data_table}.post;

{params.sentieon_exec} driver -t {threads} --algo QualCal --plot --before {output.recal_data_table} --after {output.recal_data_table}.post {output.qual_recal};

{params.sentieon_exec} plot QualCal -o {output.qual_recal_plot} {output.qual_recal};
        """
