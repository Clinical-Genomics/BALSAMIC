# vim: syntax=python tabstop=4 expandtab
# coding: utf-8

shell.prefix('set -eo pipefail;')

from BALSAMIC.utils.rule import get_conda_env
from BALSAMIC.utils.rule import get_sample_type
from BALSAMIC.utils.rule import get_threads

# Extract umi tags using the defined read structure. 
rule sentieon_umi_extract:
    input:
        read1 = fastq_dir + "{sample}_1.fastq.gz",
        read2 = fastq_dir + "{sample}_2.fastq.gz",
    output:
        ds_umi = umi_dir + '{sample}_umiextract.fastq.gz'
    params:
        sentieon_exec = SENTIEON_INSTALL_DIR + 'bin/sentieon',
        sentieon_lic = SENTIEON_LICENSE,
        ds_params= ['-d', '3M2S+T,3M2S+T'],
        sample_id = '{sample}'
    log: 
        umi_dir + '{sample}_umiextract.log'
    benchmark: 
        benchmark_dir + '{sample}_umiextract.tsv'
    message: 
        "UMI tag extraction using Sentieon for sample {params.sample_id}"
    threads: get_threads(cluster_config, 'sentieon_umi_extract')
    shell:
        "export SENTIEON_LICENSE={params.sentieon_lic}\n"
        "{params.sentieon_exec} umi extract {params.ds_params} {input.read1} {input.read2} -o {output.ds_umi} &> {log} \n"


# Align the UMI-extracted reads
rule sentieon_umi_align:
    input:
        ref_fa = config["reference"]["reference_genome"],
        fastq_umi = umi_dir + '{sample}_umiextract.fastq.gz'
    output:
        align_umi = umi_dir + '{sample}_umialign.sam'
    params:
        sentieon_exec = SENTIEON_INSTALL_DIR + 'bin/sentieon',
        sentieon_lic = SENTIEON_LICENSE,
        sheader = "'@RG\\tID:Group\\tSM:{sample}\\tLB:TargetPanel\\tPL:ILLUMINA'",
        ip_bases = '1000000',
        sample_id = '{sample}'
    threads: get_threads(cluster_config, 'sentieon_umi_align')
    log: 
        umi_dir + 'logs/{sample}_umialign.log'
    benchmark : 
        benchmark_dir + 'benchmarks/{sample}_umialign.tsv'
    message:
         "Aligning of UMI extracted reads with bwa mem, sorting for sample {params.sample_id}"
    shell:
        "export SENTIEON_LICENSE={params.sentieon_lic}\n"
        "{params.sentieon_exec} bwa mem -R {params.sheader} -K {params.ip_bases} -p -t {threads} -C {input.ref_fa} {input.fastq_umi} > {output.align_umi} 2> {log}\n"

# UMI-consensus calling
rule sentieon_umi_consensus_call:
    input:
        sam_consensus = umi_dir + '{sample}_umialign.sam',
    output:
        fastq_consensus = umi_dir + '{sample}_consensuscall.fastq.gz',
    params:
        sentieon_exec = SENTIEON_INSTALL_DIR + 'bin/sentieon',
        sentieon_lic = SENTIEON_LICENSE,
        tag = 'XR',
        ip_format = 'SAM',
        sample_id = '{sample}'
    threads: 
        get_threads(cluster_config, 'sentieon_umi_consensus_call')
    log: 
        umi_dir + '{sample}_consensuscall.log'
    benchmark : 
        benchmark_dir + '{sample}_consensuscall.tsv'
    message: 
        "Consensus molecule creation for sample {params.sample_id}"
    shell:
        "export SENTIEON_LICENSE={params.sentieon_lic}\n"
        "{params.sentieon_exec} umi consensus -t {threads} -i {input.sam_consensus} -o {output.fastq_consensus} --input_format {params.ip_format} --umi_tag {params.tag} --read_name_prefix 'UMI-' &> {log}\n"

# Alignment of consensus reads
rule sentieon_umi_consensus_align:
    input:
        ref_fa = config["reference"]["reference_genome"],
        fq_consensus = umi_dir + '{sample}_consensuscall.fastq.gz',
    output:
        align_consensus = umi_dir + '{sample}_consensusalign.bam',
    params:
        sentieon_exec = SENTIEON_INSTALL_DIR + 'bin/sentieon',
        sentieon_lic = SENTIEON_LICENSE,
        sheader = "'@RG\\tID:Group\\tSM:{sample}\\tLB:TargetPanel\\tPL:ILLUMINA'",
        ip_bases = '1000000',
        sample_id = '{sample}'
    threads: 
        get_threads(cluster_config, 'sentieon_umi_consensus_align')
    log: 
        umi_dir + '{sample}_consensusalign.log'
    benchmark : 
         benchmark_dir + '{sample}_consensusalign.tsv'
    message:
         "Mapping of consensus reads with the bwa mem, sorting for sample {params.sample_id}"
    shell:
        "export SENTIEON_LICENSE={params.sentieon_lic}\n"
        "{params.sentieon_exec} bwa mem -R {params.sheader} -t {threads} -K {params.ip_bases} -p -C {input.ref_fa} {input.fq_consensus} | {params.sentieon_exec} util sort -r {input.ref_fa} --sam2bam -o {output.align_consensus} -i - 2> {log}\n"

# Variant-calling using TNscope
rule sentieon_umi_tnscope:
    input:
        bam =  umi_dir + '{sample}_consensusalign.bam',
        ref_fa = config['reference']['reference_genome'],
        bed = config['panel']['capture_kit'],
        dbsnp = config['reference']['dbsnp']
    output:
         vcf = umi_dir + '{sample}_TNscope.vcf.gz',
    params:
        sentieon_exec = SENTIEON_INSTALL_DIR + 'bin/sentieon',
        sentieon_lic = SENTIEON_LICENSE,
        algo = 'TNscope',
        tAF = '0.0005',
        TL = '0.5',
        detect = 'sv',
        error_rate = '5',
        prune_factor = '3',
        sample_id = '{sample}'
    threads: get_threads(cluster_config, 'sentieon_umi_tnscope')
    log: 
        umi_dir + '{sample}_TNscope.log'
    benchmark : 
        benchmark_dir + '{sample}_TNscope.tsv'
    message: "Calling SNVs using TNscope for sample {params.sample_id}"
    shell:
        "export SENTIEON_LICENSE={params.sentieon_lic}\n"
        "{params.sentieon_exec} driver -t {threads} -r {input.ref_fa} -i {input.bam} --algo {params.algo} --tumor_sample {params.sample_id} --dbsnp {input.dbsnp} --min_tumor_allele_frac {params.tAF} --filter_t_alt_frac {params.tAF} --min_init_tumor_lod {params.TL} --disable_detector {params.detect} --max_error_per_read {params.error_rate} --pcr_indel_model NONE --prune_factor {params.prune_factor} {output.vcf}  &> {log}\n"
