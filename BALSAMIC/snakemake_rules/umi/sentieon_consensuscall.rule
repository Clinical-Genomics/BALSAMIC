# vim: syntax=python tabstop=4 expandtab
# coding: utf-8


from BALSAMIC.utils.rule import get_conda_env
from BALSAMIC.utils.rule import get_script_path
from BALSAMIC.utils.rule import get_threads
from BALSAMIC.utils.models import UMIworkflowConfig
from BALSAMIC.utils.constants import umiworkflow_params

paramsumi = UMIworkflowConfig.parse_obj(umiworkflow_params)

# UMI-consensus calling
rule sentieon_consensuscall_umi:
    input:
        sam_consensus = umi_dir + '{sample}.umialign.bam'
    output:
        fastq_consensus = umi_dir + '{sample}.consensuscall.fastq.gz'
    benchmark:
        Path(benchmark_dir + 'sentieon_consensuscall_umi_{sample}.tsv').as_posix()
    params:
        sentieon_exec = config["SENTIEON_INSTALL_DIR"] + "/bin/sentieon",
        sentieon_lic = config["SENTIEON_LICENSE"],
        tag = paramsumi.consensuscall.tag, 
        ip_format = paramsumi.consensuscall.align_format,
        sample_id = '{sample}'
    threads: 
        get_threads(cluster_config, 'sentieon_consensuscall_umi')
    message: 
        "Consensus molecule creation using sentieon for sample {params.sample_id}"
    shell:
        """
{params.sentieon_exec} umi consensus \
-t {threads} \
-i {input.sam_consensus} \
-o {output.fastq_consensus} \
--input_format {params.ip_format} \
--umi_tag {params.tag} \
--read_name_prefix 'UMI-'; 
        """

# Alignment of consensus reads
rule sentieon_consensusalign_umi:
    input:
        ref_fa = config["reference"]["reference_genome"],
        fq_consensus = umi_dir + '{sample}.consensuscall.fastq.gz'
    output:
        align_consensus = umi_dir + '{sample}.consensusalign.bam'
    benchmark:
        Path(benchmark_dir + 'sentieon_consensusalign_umi_{sample}.tsv').as_posix()
    params:
        sentieon_exec = config["SENTIEON_INSTALL_DIR"] + "/bin/sentieon",
        sentieon_lic = config["SENTIEON_LICENSE"],
        sheader = paramsumi.consensuscall.align_header,
        ip_bases = paramsumi.consensuscall.align_intbases,
        sample_id = '{sample}'
    threads: 
        get_threads(cluster_config, 'sentieon_consensusalign_umi')
    message:
         "Mapping of consensus reads with the sentieon bwa mem, sorting for sample {params.sample_id}"
    shell:
        """
{params.sentieon_exec} bwa mem \
-R {params.sheader} \
-t {threads} \
-K {params.ip_bases} \
-p -C {input.ref_fa} \
{input.fq_consensus} | \
{params.sentieon_exec} util sort \
-r {input.ref_fa} \
--sam2bam \
-o {output.align_consensus} \
-i - ;
        """

# Filter consensus called reads based on 'XZ' filtering
rule sentieon_consensusfilter_umi:
    input:
        umi_dir + '{sample}.consensusalign.bam'
    output:
        umi_dir + '{sample}.consensusfiltered.bam'
    benchmark:
        Path(benchmark_dir + 'sentieon_consensusfilter_umi_{sample}.tsv').as_posix()
    singularity: 
        singularity_image
    params:
        consensusfilter_script = get_script_path('FilterDuplexUMIconsensus.sh'),
        minreads = paramsumi.consensuscall.filter_minreads,
        sample_id = '{sample}',
        conda = get_conda_env(config["conda_env_yaml"],"samtools")
    message:
        "Filtering consensus reads based on XZ tag for sample {params.sample_id}"
    shell:
        """
source activate {params.conda};

bash {params.consensusfilter_script} {input} {output} {params.minreads};
        """
