# vim: syntax=python tabstop=4 expandtab
# coding: utf-8


if 'quality_trim' in config['QC'].keys():
    fastp_param_qc = list()
    fastp_param_adapter = list()
    fastp_param_umi = list()
    if config['QC']['quality_trim']:
        fastp_param_qc.extend(["--trim_tail1", "1", "--n_base_limit", "50",
                            "--length_required", config["QC"]["min_seq_length"],
                            "--low_complexity_filter", "--trim_poly_g"])
    else:
        fastp_param_qc.extend(["--disable_quality_filtering",
                               "--disable_length_filtering",
                               "--disable_trim_poly_g"])

    if not config['QC']['adapter_trim']:
        fastp_param_adapter.extend(["--disable_adapter_trimming"])
    else:
        fastp_param_adapter.extend(["--detect_adapter_for_pe"])

    # UMI trimming will work only if adapter_trim is disabled
    if config['QC']['umi_trim']:
        fastp_param_umi.extend(["--umi","--umi_loc per_read",
                                "--umi_len", config['QC']['umi_trim_length'],
                                "--umi_prefix","UMI"])

    # Don't evaluate duplicates
    fastp_param_qc.extend(["--dont_eval_duplication"])
    fastp_param_umi.extend(["--dont_eval_duplication"])


rule fastp_umi:
    """Fastq UMI data pre-processing."""
    input:
        fastq_r1 = lambda wildcards: fastq_dict[wildcards.fastqpattern]["fwd"],
        fastq_r2 = lambda wildcards: fastq_dict[wildcards.fastqpattern]["rev"]
    output:
        fastq_r1 = temp(fastq_dir + "{fastqpattern}_1.umi_optimized.fastq.gz"),
        fastq_r2 = temp(fastq_dir + "{fastqpattern}_2.umi_optimized.fastq.gz"),
        json = qc_dir + "fastp/{fastqpattern}_fastp_umi.json",
        html = qc_dir + "fastp/{fastqpattern}_fastp_umi.html",
    benchmark:
        Path(benchmark_dir, "fastp_umi" + "{fastqpattern}.tsv").as_posix()
    singularity:
        Path(singularity_image, config["bioinfo_tools"].get("fastp") + ".sif").as_posix()
    params:
        tmpdir = tmp_dir,
        qc = " ".join(fastp_param_qc),
        adapter = " ".join(fastp_param_adapter),
        fastqpattern = "{fastqpattern}",
    threads:
        get_threads(cluster_config, 'fastp_umi')
    message:
        "Quality control and trimming input fastq for {params.fastqpattern}"
    shell:
        """
export TMPDIR={params.tmpdir};

fastp \
--thread {threads} \
--in1 {input.fastq_r1} \
--in2 {input.fastq_r2} \
--out1 {output.fastq_r1} \
--out2 {output.fastq_r2} \
--json {output.json} \
--html {output.html} \
--overrepresentation_analysis \
{params.qc} \
{params.adapter};
        """
# Double pass to hard trim adapter and UMIs


rule fastp:
    """Fastq data pre-processing."""
    input:
        fastq_r1 = fastq_dir + "{fastqpattern}_1.umi_optimized.fastq.gz",
        fastq_r2 = fastq_dir + "{fastqpattern}_2.umi_optimized.fastq.gz"
    output:
        fastq_r1 = temp(fastq_dir + "{fastqpattern}_1.fp.fastq.gz"),
        fastq_r2 = temp(fastq_dir + "{fastqpattern}_2.fp.fastq.gz"),
        json = qc_dir + "fastp/{fastqpattern}_fastp.json",
        html = qc_dir + "fastp/{fastqpattern}_fastp.html"
    benchmark:
        Path(benchmark_dir, "fastp_" + "{fastqpattern}.tsv").as_posix()
    singularity: 
        Path(singularity_image, config["bioinfo_tools"].get("fastp") + ".sif").as_posix()
    params:
        tmpdir = tmp_dir,
        umi = " ".join(fastp_param_umi),
        minimum_length = config["QC"]["min_seq_length"],
        fastqpattern = "{fastqpattern}",
    threads:
        get_threads(cluster_config, 'fastp')
    message:
        "Quality control and trimming of umi optimized fastq file for {params.fastqpattern}"
    shell:
        """
export TMPDIR={params.tmpdir};

fastp \
--thread {threads} \
--in1 {input.fastq_r1} \
--in2 {input.fastq_r2} \
--out1 {output.fastq_r1} \
--out2 {output.fastq_r2} \
--json {output.json} \
--html {output.html} \
--disable_adapter_trimming \
--disable_quality_filtering \
--disable_length_filtering \
--disable_trim_poly_g \
--length_required {params.minimum_length} \
{params.umi};
        """
