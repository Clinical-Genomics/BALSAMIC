"""Rules for TGA fastq pre-processing: removal UMIs and quality and adapter-trimming."""

fastp_param_umi = list()
fastp_param_umi.extend(["--umi","--umi_loc per_read", "--umi_len", config['QC']['umi_trim_length'], "--umi_prefix","UMI"])
fastp_param_umi.extend(["--dont_eval_duplication"])

rule fastp_remove_umi:
    """Fastq TGA data pre-processing to remove UMIs."""
    input:
        fastq_r1 = lambda wildcards: balsamic.get_fastq_by_fastq_pattern(wildcards.fastq_pattern, FastqName.FWD),
        fastq_r2 = lambda wildcards: balsamic.get_fastq_by_fastq_pattern(wildcards.fastq_pattern, FastqName.REV)
    output:
        fastq_r1 = temp(fastq_dir + "{fastq_pattern}_1.umi_removed.fastq.gz"),
        fastq_r2 = temp(fastq_dir + "{fastq_pattern}_2.umi_removed.fastq.gz"),
        json = qc_dir + "fastp/{fastq_pattern}_umi_removed_fastp.json",
        html = qc_dir + "fastp/{fastq_pattern}_umi_removed_fastp.html",
    benchmark:
        Path(benchmark_dir, "fastp_remove_umi" + "{fastq_pattern}.tsv").as_posix()
    singularity:
        Path(singularity_image, config["bioinfo_tools"].get("fastp") + ".sif").as_posix()
    params:
        tmpdir = tmp_dir,
        fastp_settings = " ".join(fastp_param_umi),
        fastq_pattern = "{fastq_pattern}",
    threads:
        get_threads(cluster_config, 'fastp_umi')
    message:
        "Trimming away UMI sequences for fastqs in fastq pattern: {params.fastq_pattern}"
    shell:
        """
export TMPDIR={params.tmpdir};

fastp \
--thread {threads} \
--in1 {input.fastq_r1} \
--in2 {input.fastq_r2} \
--out1 {output.fastq_r1} \
--out2 {output.fastq_r2} \
--json {output.json} \
--html {output.html} \
--disable_adapter_trimming \
--disable_quality_filtering \
--disable_length_filtering \
--disable_trim_poly_g \
{params.fastp_param_umi};
        """

if 'quality_trim' in config['QC'].keys():
    fastp_param_qc = list()
    fastp_param_adapter = list()
    if config['QC']['quality_trim']:
        fastp_param_qc.extend(["--trim_tail1", "1", "--n_base_limit", "50",
                            "--length_required", config["QC"]["min_seq_length"],
                            "--low_complexity_filter", "--trim_poly_g"])
    else:
        fastp_param_qc.extend(["--disable_quality_filtering",
                               "--disable_length_filtering",
                               "--disable_trim_poly_g"])

    if not config['QC']['adapter_trim']:
        fastp_param_adapter.extend(["--disable_adapter_trimming"])
    else:
        fastp_param_adapter.extend(["--detect_adapter_for_pe"])

    fastp_param_qc.extend(["--dont_eval_duplication"])

rule fastp_quality_trim:
    """Fastq data pre-processing after removal of UMIs."""
    input:
        fastq_r1 = temp(fastq_dir + "{fastq_pattern}_1.umi_removed.fastq.gz"),
        fastq_r2 = temp(fastq_dir + "{fastq_pattern}_2.umi_removed.fastq.gz")
    output:
        fastq_r1 = temp(fastq_dir + "{fastq_pattern}_1.fp.fastq.gz"),
        fastq_r2 = temp(fastq_dir + "{fastq_pattern}_2.fp.fastq.gz"),
        json = qc_dir + "fastp/{fastq_pattern}_fastp.json",
        html = qc_dir + "fastp/{fastq_pattern}_fastp.html"
    benchmark:
        Path(benchmark_dir, "fastp_quality_trim" + "{fastq_pattern}.tsv").as_posix()
    singularity:
        Path(singularity_image, config["bioinfo_tools"].get("fastp") + ".sif").as_posix()
    params:
        tmpdir = tmp_dir,
        qc = " ".join(fastp_param_qc),
        adapter = " ".join(fastp_param_adapter),
        fastq_pattern = "{fastq_pattern}"
    threads:
        get_threads(cluster_config, 'fastp')
    message:
        "Quality control and trimming of UMI-removed fastqs for fastq pattern: {params.fastq_pattern}"
    shell:
        """
export TMPDIR={params.tmpdir};

fastp \
--thread {threads} \
--in1 {input.fastq_r1} \
--in2 {input.fastq_r2} \
--out1 {output.fastq_r1} \
--out2 {output.fastq_r2} \
--json {output.json} \
--html {output.html} \
--overrepresentation_analysis \
{params.qc} \
{params.adapter};
        """
